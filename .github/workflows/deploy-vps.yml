name: Deploy VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: deploy-vps-main
  cancel-in-progress: true

jobs:
  build-images:
    name: Build and Push (${{ matrix.service }})
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        service: [web, api]

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve image metadata
        id: meta
        run: |
          echo "owner=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"
          echo "sha_tag=${GITHUB_SHA}" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push web image
        if: matrix.service == 'web'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./web/Dockerfile
          push: true
          build-args: |
            NEXT_PUBLIC_API_URL=https://api.splitup.appverso.com.br
          tags: |
            ghcr.io/${{ steps.meta.outputs.owner }}/splitup-web:prod
            ghcr.io/${{ steps.meta.outputs.owner }}/splitup-web:${{ steps.meta.outputs.sha_tag }}

      - name: Build and push api image
        if: matrix.service == 'api'
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./api/Dockerfile
          push: true
          tags: |
            ghcr.io/${{ steps.meta.outputs.owner }}/splitup-api:prod
            ghcr.io/${{ steps.meta.outputs.owner }}/splitup-api:${{ steps.meta.outputs.sha_tag }}

  deploy:
    name: Deploy on VPS
    runs-on: ubuntu-latest
    needs: build-images

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Resolve image namespace
        id: ns
        run: |
          echo "owner=${GITHUB_REPOSITORY_OWNER,,}" >> "$GITHUB_OUTPUT"

      - name: Prepare SSH key
        env:
          VPS_SSH_KEY: ${{ secrets.VPS_SSH_KEY }}
        run: |
          set -euo pipefail
          mkdir -p ~/.ssh
          printf '%s\n' "$VPS_SSH_KEY" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Trigger Portainer redeploy (webhook first, API fallback)
        id: trigger
        env:
          PORTAINER_WEBHOOK_URL: ${{ secrets.PORTAINER_WEBHOOK_URL }}
          PORTAINER_URL: ${{ secrets.PORTAINER_URL }}
          PORTAINER_STACK_ID: ${{ secrets.PORTAINER_STACK_ID }}
          PORTAINER_ENDPOINT_ID: ${{ secrets.PORTAINER_ENDPOINT_ID }}
          PORTAINER_API_TOKEN: ${{ secrets.PORTAINER_API_TOKEN }}
        run: |
          set -euo pipefail

          redeploy_done=false

          if [ -n "${PORTAINER_WEBHOOK_URL:-}" ]; then
            echo "[INFO] Triggering Portainer webhook..."
            if curl -fsS -X POST "$PORTAINER_WEBHOOK_URL"; then
              redeploy_done=true
              echo "[INFO] Webhook redeploy accepted."
            else
              echo "[WARN] Webhook call failed. Trying API fallback..."
            fi
          else
            echo "[WARN] PORTAINER_WEBHOOK_URL not configured. Trying API fallback..."
          fi

          if [ "$redeploy_done" = "false" ]; then
            if [ -n "${PORTAINER_URL:-}" ] && [ -n "${PORTAINER_STACK_ID:-}" ] && [ -n "${PORTAINER_ENDPOINT_ID:-}" ] && [ -n "${PORTAINER_API_TOKEN:-}" ]; then
              curl -fsS -X PUT \
                -H "X-API-Key: ${PORTAINER_API_TOKEN}" \
                "${PORTAINER_URL}/api/stacks/${PORTAINER_STACK_ID}/git/redeploy?endpointId=${PORTAINER_ENDPOINT_ID}"

              redeploy_done=true
              echo "[INFO] Portainer API redeploy accepted."
            else
              echo "[WARN] Portainer API fallback not configured. Will use SSH fallback."
            fi
          fi

          echo "redeploy_done=${redeploy_done}" >> "$GITHUB_OUTPUT"

      - name: Sync /opt/splitup/vps.env (optional)
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          VPS_ENV_FILE: ${{ secrets.VPS_ENV_FILE }}
        run: |
          set -euo pipefail

          if [ -z "${VPS_ENV_FILE:-}" ]; then
            echo "[WARN] VPS_ENV_FILE not configured. Skipping /opt/splitup/vps.env sync."
            exit 0
          fi

          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=accept-new "${VPS_USER}@${VPS_HOST}" 'mkdir -p /opt/splitup'
          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=accept-new "${VPS_USER}@${VPS_HOST}" 'cat > /opt/splitup/vps.env' <<< "$VPS_ENV_FILE"
          echo "[INFO] /opt/splitup/vps.env updated on VPS."

      - name: SSH fallback deploy (docker stack deploy)
        if: steps.trigger.outputs.redeploy_done != 'true'
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
          GHCR_USER: ${{ github.actor }}
          GHCR_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GHCR_NAMESPACE: ${{ steps.ns.outputs.owner }}
        run: |
          set -euo pipefail

          : "${VPS_HOST:?VPS_HOST is required for SSH fallback}"
          : "${VPS_USER:?VPS_USER is required for SSH fallback}"

          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=accept-new \
            deploy/vps/stack.yml \
            "${VPS_USER}@${VPS_HOST}:/opt/splitup/stack.yml"

          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=accept-new "${VPS_USER}@${VPS_HOST}" \
            "GHCR_USER='${GHCR_USER}' GHCR_TOKEN='${GHCR_TOKEN}' GHCR_NAMESPACE='${GHCR_NAMESPACE}' bash -s" <<'EOSSH'
            set -euo pipefail

            if [ ! -f /opt/splitup/vps.env ]; then
              echo "[ERROR] /opt/splitup/vps.env nÃ£o encontrado. Configure VPS_ENV_FILE secret ou crie o arquivo manualmente." >&2
              exit 1
            fi

            echo "$GHCR_TOKEN" | docker login ghcr.io -u "$GHCR_USER" --password-stdin

            set -a
            . /opt/splitup/vps.env
            set +a
            export GHCR_NAMESPACE="$GHCR_NAMESPACE"
            export IMAGE_TAG="${IMAGE_TAG:-prod}"

            docker stack deploy --with-registry-auth -c /opt/splitup/stack.yml splitup
            docker service ls --format '{{.Name}} {{.Replicas}}' | grep '^splitup_' || true
          EOSSH

      - name: Wait for health endpoints
        run: |
          set -euo pipefail

          check_url() {
            local url="$1"
            local attempts=30
            local sleep_seconds=10
            local i

            for i in $(seq 1 "$attempts"); do
              if curl -fsS --max-time 10 "$url" >/dev/null; then
                echo "[INFO] Healthy: $url"
                return 0
              fi
              echo "[INFO] Waiting for $url ($i/$attempts)..."
              sleep "$sleep_seconds"
            done

            echo "[ERROR] Healthcheck failed: $url" >&2
            return 1
          }

          check_url "https://splitup.appverso.com.br"
          check_url "https://api.splitup.appverso.com.br/status"

      - name: Update /opt/AGENTS.md on VPS
        env:
          VPS_HOST: ${{ secrets.VPS_HOST }}
          VPS_USER: ${{ secrets.VPS_USER }}
        run: |
          set -euo pipefail

          scp -i ~/.ssh/id_rsa -o StrictHostKeyChecking=accept-new \
            deploy/vps/scripts/generate-vps-agents.sh \
            "${VPS_USER}@${VPS_HOST}:/tmp/generate-vps-agents.sh"

          ssh -i ~/.ssh/id_rsa -o StrictHostKeyChecking=accept-new "${VPS_USER}@${VPS_HOST}" '
            set -euo pipefail
            chmod +x /tmp/generate-vps-agents.sh
            /tmp/generate-vps-agents.sh
            rm -f /tmp/generate-vps-agents.sh
            if command -v sudo >/dev/null 2>&1; then
              sudo test -f /opt/AGENTS.md
              sudo head -n 20 /opt/AGENTS.md
            else
              test -f /opt/AGENTS.md
              head -n 20 /opt/AGENTS.md
            fi
          '
